require 'packetfu'

def error(incident_number, attack, packet) 
    source_IP_address = packet.ip_saddr;
    protocol = packet.ip_proto.last;
    #{incident_number}. ALERT: #{attack} from #{source_IP_address} (#{protocol})!
    incident_number+=1
end

incident number = 0;

caps = PacketFu::Capture.new(:start=> true, :iface => 'eth0', :promise => true)
caps.stream.each do |raw| #iterate all captured packets
packet = PacketFu::Packet.parse(raw) #returns correct packet subclass based on raw data


       if packet.proto[1] == "IP"

       	  if packet.proto[2] == "TCP"

	     if packet.tcp_flags.urg==0 and packet.tcp_flags.ack==0 and packet.tcp_flags.psh==0 and packet.tcp_flags.rst==0 and packet.tcp_flags.syn==0 and packet.tcp_flags.fin==0
	     error(incident_number, "Null scan is detected", packet)	 
	     end

	     if packet.tcp_flags.urg==1 and packet.tcp_flags.ack==0 and packet.tcp_flags.psh==1 and packet.tcp_flags.rst==0 and packet.tcp_flags.syn==0 and packet.tcp_flags.fin==1
	     error(incident_number, "Xmas scan is detected", packet)
	     end
	
	  end

	payload = packet.payload;

	if payload.match /Nmap/
	   error(incident_number, "Nmap scan is detected", packet)
	end

	if payload.match /pass/
	   error(incident_number, "Password leak is detected", packet)
	end

	if payload.match /PASS/
	   error(incident_number, "Password leak is detected", packet)
	end

	if payload.match /<script>alert\(.*\);< /
	   error(incident_number, "Cross scripting is detected", packet)
	end

	if payload.match /<script>window.location.* /
	   error(incident_number, "Cross scripting is detected", packet)
	end

	if payload.match /\d{4}-\d{4}-\d{4}-\d{4} /
	   error(incident_number, "Credit card leaked in the clear", packet)
	end

	if payload.match /\d{4} \d{4} \d{4} \d{4} /
	   error(incident_number, "Credit card leaked in the clear", packet)
	end

	if payload.match /\d{16} /
	   error(incident_number, "Credit card leaked in the clear", packet)
	end


       end

end